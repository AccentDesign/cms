// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: page.sql

package dbx

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPageAncestors = `-- name: GetPageAncestors :many
SELECT id, path, level, url, page_type, title, tags, categories, is_in_sitemap, is_searchable, search_vector, full_text, no_cache, priority, change_frequency, created_at, updated_at, published_at, meta_description, meta_og_site_name, meta_og_title, meta_og_description, meta_og_url, meta_og_type, meta_og_image, meta_og_image_secure_url, meta_og_image_width, meta_og_image_height, meta_article_publisher, meta_article_section, meta_article_tag, meta_twitter_card, meta_twitter_image, meta_twitter_site, meta_robots
FROM page
WHERE path @> $1::ltree
AND published_at <= clock_timestamp()
ORDER BY level
`

// get ancestors of a page
func (q *Queries) GetPageAncestors(ctx context.Context, dollar_1 string) ([]Page, error) {
	rows, err := q.db.Query(ctx, getPageAncestors, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Level,
			&i.Url,
			&i.PageType,
			&i.Title,
			&i.Tags,
			&i.Categories,
			&i.IsInSitemap,
			&i.IsSearchable,
			&i.SearchVector,
			&i.FullText,
			&i.NoCache,
			&i.Priority,
			&i.ChangeFrequency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.MetaDescription,
			&i.MetaOgSiteName,
			&i.MetaOgTitle,
			&i.MetaOgDescription,
			&i.MetaOgUrl,
			&i.MetaOgType,
			&i.MetaOgImage,
			&i.MetaOgImageSecureUrl,
			&i.MetaOgImageWidth,
			&i.MetaOgImageHeight,
			&i.MetaArticlePublisher,
			&i.MetaArticleSection,
			&i.MetaArticleTag,
			&i.MetaTwitterCard,
			&i.MetaTwitterImage,
			&i.MetaTwitterSite,
			&i.MetaRobots,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageByPath = `-- name: GetPageByPath :one
SELECT p.id, p.path, p.level, p.url, p.page_type, p.title, p.tags, p.categories, p.is_in_sitemap, p.is_searchable, p.search_vector, p.full_text, p.no_cache, p.priority, p.change_frequency, p.created_at, p.updated_at, p.published_at, p.meta_description, p.meta_og_site_name, p.meta_og_title, p.meta_og_description, p.meta_og_url, p.meta_og_type, p.meta_og_image, p.meta_og_image_secure_url, p.meta_og_image_width, p.meta_og_image_height, p.meta_article_publisher, p.meta_article_section, p.meta_article_tag, p.meta_twitter_card, p.meta_twitter_image, p.meta_twitter_site, p.meta_robots, tableoid::regclass::varchar as source
FROM page p
WHERE path = $1::ltree
AND published_at <= clock_timestamp()
LIMIT 1
`

type GetPageByPathRow struct {
	Page   Page
	Source string
}

// get a page by its path
func (q *Queries) GetPageByPath(ctx context.Context, dollar_1 string) (GetPageByPathRow, error) {
	row := q.db.QueryRow(ctx, getPageByPath, dollar_1)
	var i GetPageByPathRow
	err := row.Scan(
		&i.Page.ID,
		&i.Page.Path,
		&i.Page.Level,
		&i.Page.Url,
		&i.Page.PageType,
		&i.Page.Title,
		&i.Page.Tags,
		&i.Page.Categories,
		&i.Page.IsInSitemap,
		&i.Page.IsSearchable,
		&i.Page.SearchVector,
		&i.Page.FullText,
		&i.Page.NoCache,
		&i.Page.Priority,
		&i.Page.ChangeFrequency,
		&i.Page.CreatedAt,
		&i.Page.UpdatedAt,
		&i.Page.PublishedAt,
		&i.Page.MetaDescription,
		&i.Page.MetaOgSiteName,
		&i.Page.MetaOgTitle,
		&i.Page.MetaOgDescription,
		&i.Page.MetaOgUrl,
		&i.Page.MetaOgType,
		&i.Page.MetaOgImage,
		&i.Page.MetaOgImageSecureUrl,
		&i.Page.MetaOgImageWidth,
		&i.Page.MetaOgImageHeight,
		&i.Page.MetaArticlePublisher,
		&i.Page.MetaArticleSection,
		&i.Page.MetaArticleTag,
		&i.Page.MetaTwitterCard,
		&i.Page.MetaTwitterImage,
		&i.Page.MetaTwitterSite,
		&i.Page.MetaRobots,
		&i.Source,
	)
	return i, err
}

const getPageChildren = `-- name: GetPageChildren :many
SELECT id, path, level, url, page_type, title, tags, categories, is_in_sitemap, is_searchable, search_vector, full_text, no_cache, priority, change_frequency, created_at, updated_at, published_at, meta_description, meta_og_site_name, meta_og_title, meta_og_description, meta_og_url, meta_og_type, meta_og_image, meta_og_image_secure_url, meta_og_image_width, meta_og_image_height, meta_article_publisher, meta_article_section, meta_article_tag, meta_twitter_card, meta_twitter_image, meta_twitter_site, meta_robots
FROM page
WHERE path <@ $1::ltree
AND level = nlevel($1::ltree) + 1
AND published_at <= clock_timestamp()
ORDER BY path
`

// get the children of a page
func (q *Queries) GetPageChildren(ctx context.Context, dollar_1 string) ([]Page, error) {
	rows, err := q.db.Query(ctx, getPageChildren, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.Level,
			&i.Url,
			&i.PageType,
			&i.Title,
			&i.Tags,
			&i.Categories,
			&i.IsInSitemap,
			&i.IsSearchable,
			&i.SearchVector,
			&i.FullText,
			&i.NoCache,
			&i.Priority,
			&i.ChangeFrequency,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.MetaDescription,
			&i.MetaOgSiteName,
			&i.MetaOgTitle,
			&i.MetaOgDescription,
			&i.MetaOgUrl,
			&i.MetaOgType,
			&i.MetaOgImage,
			&i.MetaOgImageSecureUrl,
			&i.MetaOgImageWidth,
			&i.MetaOgImageHeight,
			&i.MetaArticlePublisher,
			&i.MetaArticleSection,
			&i.MetaArticleTag,
			&i.MetaTwitterCard,
			&i.MetaTwitterImage,
			&i.MetaTwitterSite,
			&i.MetaRobots,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPagesForSearch = `-- name: GetPagesForSearch :many
SELECT
    id,
    title,
    meta_description,
    url,
    ts_headline('english', full_text, plainto_tsquery('english', $1)) AS headline,
    ts_rank(search_vector, plainto_tsquery('english', $1)) AS rank
FROM page
WHERE is_searchable
AND path <@ $2::ltree
AND published_at <= clock_timestamp()
AND search_vector @@ plainto_tsquery('english', $1)
ORDER BY rank DESC
LIMIT $3
`

type GetPagesForSearchParams struct {
	PlaintoTsquery string
	BasePath       string
	Limit          int64
}

type GetPagesForSearchRow struct {
	ID              int32
	Title           string
	MetaDescription pgtype.Text
	Url             pgtype.Text
	Headline        string
	Rank            float32
}

// get the pages for the search results
// base_path:
// a path to start the search from, eg: 'about' will search for pages that are descendents of about.
// this allows for multiple searches across branches of the site.
func (q *Queries) GetPagesForSearch(ctx context.Context, arg GetPagesForSearchParams) ([]GetPagesForSearchRow, error) {
	rows, err := q.db.Query(ctx, getPagesForSearch, arg.PlaintoTsquery, arg.BasePath, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPagesForSearchRow{}
	for rows.Next() {
		var i GetPagesForSearchRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.MetaDescription,
			&i.Url,
			&i.Headline,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPagesForSitemap = `-- name: GetPagesForSitemap :many
SELECT
    url,
    updated_at,
    change_frequency,
    priority::float4
FROM page
WHERE is_in_sitemap
AND published_at <= clock_timestamp()
ORDER BY path
`

type GetPagesForSitemapRow struct {
	Url             pgtype.Text
	UpdatedAt       pgtype.Timestamp
	ChangeFrequency ChangeFrequency
	Priority        float32
}

// get the pages for the sitemap
func (q *Queries) GetPagesForSitemap(ctx context.Context) ([]GetPagesForSitemapRow, error) {
	rows, err := q.db.Query(ctx, getPagesForSitemap)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPagesForSitemapRow{}
	for rows.Next() {
		var i GetPagesForSitemapRow
		if err := rows.Scan(
			&i.Url,
			&i.UpdatedAt,
			&i.ChangeFrequency,
			&i.Priority,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
